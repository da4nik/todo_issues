package github

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"

	"github.com/da4nik/todo_issues/types"
)

// Github represents github integration
type Github struct {
	accessToken string
	owner       string
	repo        string
}

type createIssueParams struct {
	Title  string   `json:"title"`
	Body   string   `json:"body"`
	Labels []string `json:"labels"`
}

type createIssueResponse struct {
	ID     int    `json:"id"`
	URL    string `json:"url"`
	Number int    `json:"number"`
}

const baseAPIURL = "https://api.github.com"
const baseLinksURL = "https://github.com"
const acceptHeader = "application/vnd.github.v3+json"

// New - creates new github integration object
func New(token, owner, repo string) Github {
	// TODO: #14 Determine current repo from .git directory
	// TODO: #14 https://api.github.com/repos/da4nik/todo_issues/issues/14
	return Github{
		accessToken: token,
		owner:       owner,
		repo:        repo,
	}
}

// CreateIssue creates and issue in a github repo
func (g Github) CreateIssue(title, filename string, lineNumber int) types.IntegrationResponse {
	url := fmt.Sprintf("%s/repos/%s/%s/issues", baseAPIURL, g.owner, g.repo)
	todoLink := fmt.Sprintf("%s/%s/%s/%s#L%d", baseLinksURL, g.owner, g.repo, filename, lineNumber)

	payload, err := json.Marshal(createIssueParams{
		Title:  title,
		Body:   todoLink,
		Labels: []string{"Autogenerated"},
	})
	if err != nil {
		fmt.Printf("Error making json: %s\n", err.Error())
		return types.IntegrationResponse{}
	}

	req, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(payload))
	if err != nil {
		fmt.Printf("Error creating request: %s\n", err.Error())
		return types.IntegrationResponse{}
	}

	req.Header.Set("Accept", acceptHeader)
	req.Header.Set("Authorization", fmt.Sprintf("token %s", g.accessToken))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Error creating issue on a github: %s\n", err.Error())
		return types.IntegrationResponse{}
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return types.IntegrationResponse{}
	}

	body, _ := ioutil.ReadAll(resp.Body)

	var result createIssueResponse
	if err = json.Unmarshal(body, &result); err != nil {
		fmt.Printf("Unable to unmarshal reponse: %s\n", err.Error())
		return types.IntegrationResponse{}
	}

	return types.IntegrationResponse{
		ID:        strconv.Itoa(result.Number),
		IssueLink: result.URL,
	}
}
